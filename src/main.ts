import { checkBalance, setHyperliquidTrader, setBybitTrader } from "./trader";
import { TelegramService } from "./telegramService";
import { startHealthCheck } from './healthCheck';

import { HyperliquidTrader } from './hyperliquidTrader';
import { BinanceTrader } from './binanceTrader';
import { BybitTrader } from './bybitTrader';
import { validateHyperliquidConfig } from './hyperliquidConfig';
import { TradeRetryManager } from './retryManager';
import { PerformanceMonitor } from './performanceMonitor';
import { RiskManager } from './riskManager';
import { DiagnosticTool } from './diagnostic';
import { ListingQueue } from './listingQueue';
import { GlobalTokenManager } from './globalTokenManager';
import { PositionOrchestrator, ListingEvent } from './execution/positionOrchestrator';
import { ListingSurveillance, KoreanListingEvent } from './listingSurveillance';
console.log("üöÄ Frontrun Bot is running!");

// Mode Railway - r√©duire les logs pour √©viter les probl√®mes de performance
const isRailway = process.env.RAILWAY_ENVIRONMENT || process.env.NODE_ENV === 'production';
if (isRailway) {
  console.log("üöÇ Mode Railway d√©tect√© - Logs optimis√©s activ√©s");
  // R√©duire la verbosit√© des logs en production
  process.env.ENABLE_KOREAN_LOGS = 'false';
  process.env.ENABLE_VERBOSE_LOGS = 'false';
}

// Variables globales
let traderInitialized = false;

let hyperliquidTrader: HyperliquidTrader | undefined = undefined;
let telegramService: TelegramService | null = null;
let retryManager: TradeRetryManager | null = null;
let performanceMonitor: PerformanceMonitor | null = null;
let riskManager: RiskManager | null = null;
let listingQueue: ListingQueue | null = null;
let globalTokenManager: GlobalTokenManager | null = null;
let positionOrchestrator: PositionOrchestrator | null = null;
let listingSurveillance: ListingSurveillance | null = null;



async function startBot() {
  try {
    console.log("ü§ñ Initialisation du bot...");
    
    // Validation de la configuration Railway
    // const railwayConfig = validateRailwayConfig(); // This line is removed
    // const configErrors = getMissingConfigErrors(); // This line is removed
    
    // if (configErrors.length > 0) { // This block is removed
    //   console.error("‚ùå Erreurs de configuration Railway:"); // This block is removed
    //   configErrors.forEach(error => console.error(`  - ${error}`)); // This block is removed
    //   console.error("‚ö†Ô∏è Le bot continuera en mode surveillance uniquement"); // This block is removed
    // } // This block is removed
    
    // Diagnostic syst√®me au d√©marrage
    console.log("üîç Ex√©cution du diagnostic syst√®me...");
    const diagnosticTool = new DiagnosticTool();
    await diagnosticTool.runDiagnostic();
    
    // Initialiser le rapporteur de statut
    // const statusReporter = new StatusReporter();
    // statusReporter.startReporting();
    // D√âSACTIV√â - Rapport automatique toutes les 2h (source possible de spam)
    
    // Valider la configuration Hyperliquid
    validateHyperliquidConfig();
    
    // Initialiser le service Telegram s√©curis√©
    telegramService = new TelegramService();
    
    // Initialiser les nouveaux modules
    console.log("üìä Initialisation des modules avanc√©s...");
    retryManager = new TradeRetryManager(telegramService);
    performanceMonitor = new PerformanceMonitor(telegramService);
    riskManager = new RiskManager(telegramService);
    // Article scraper d√©sactiv√© (Cloudflare protection)

    // Initialiser le gestionnaire de tokens globaux
    console.log("üåç Initialisation du gestionnaire de tokens globaux...");
    globalTokenManager = new GlobalTokenManager(telegramService);
    
    // D√©sactiver la surveillance globale par d√©faut - Focus sur Cor√©e
    if (process.env.ENABLE_GLOBAL_MONITORING === 'true') {
      globalTokenManager.startGlobalMonitoring();
    } else {
      console.log("‚è∏Ô∏è Surveillance globale d√©sactiv√©e - Focus sur frontrunning cor√©en");
    }

    // Initialiser la surveillance des listings cor√©ens
    console.log("üá∞üá∑ Initialisation de la surveillance des listings cor√©ens...");
    listingSurveillance = new ListingSurveillance(handleNewListing);
    await listingSurveillance.start();



    // Initialiser les traders
    console.log("üí∞ Initialisation des traders...");
    
    let tradersInitialized = 0;
    
    // Initialiser Hyperliquid (priorit√©)
    if (process.env.HL_ENABLED === '1') {
      console.log("üîß Initialisation du trader Hyperliquid...");
      try {
        hyperliquidTrader = new HyperliquidTrader();
        const hlInitialized = await hyperliquidTrader.initialize();
        if (hlInitialized) {
          console.log("‚úÖ Trader Hyperliquid initialis√© avec succ√®s");
          traderInitialized = true;
          tradersInitialized++;
          // Synchroniser avec trader.ts
          setHyperliquidTrader(hyperliquidTrader);
        } else {
          console.log("‚ö†Ô∏è √âchec initialisation Hyperliquid");
        }
      } catch (error) {
        console.error("‚ùå Erreur initialisation Hyperliquid:", error);
      }
    } else {
      console.log("‚è∏Ô∏è Hyperliquid d√©sactiv√© (HL_ENABLED != 1)");
    }

    // Initialiser Binance (si activ√©)
    let binanceTrader: BinanceTrader | undefined = undefined;
    if (process.env.BINANCE_ENABLED === '1') {
      console.log("üîß Initialisation du trader Binance...");
      try {
        binanceTrader = new BinanceTrader(telegramService);
        const binanceInitialized = await binanceTrader.initialize();
        if (binanceInitialized) {
          console.log("‚úÖ Trader Binance initialis√© avec succ√®s");
          if (!traderInitialized) traderInitialized = true;
          tradersInitialized++;
        } else {
          console.log("‚ö†Ô∏è √âchec initialisation Binance");
        }
      } catch (error) {
        console.error("‚ùå Erreur initialisation Binance:", error);
      }
    } else {
      console.log("‚è∏Ô∏è Binance d√©sactiv√© (BINANCE_ENABLED != 1)");
    }

    // Initialiser Bybit (si activ√©)
    let bybitTrader: BybitTrader | undefined = undefined;
    if (process.env.BYBIT_ENABLED === '1') {
      console.log("üîß Initialisation du trader Bybit...");
      try {
        bybitTrader = new BybitTrader();
        const bybitInitialized = await bybitTrader.initialize();
        if (bybitInitialized) {
          console.log("‚úÖ Trader Bybit initialis√© avec succ√®s");
          if (!traderInitialized) traderInitialized = true;
          tradersInitialized++;
        } else {
          console.log("‚ö†Ô∏è √âchec initialisation Bybit");
        }
      } catch (error) {
        console.error("‚ùå Erreur initialisation Bybit:", error);
      }
    } else {
      console.log("‚è∏Ô∏è Bybit d√©sactiv√© (BYBIT_ENABLED != 1)");
    }
    
    console.log(`üìä R√©sum√© traders: ${tradersInitialized} trader(s) initialis√©(s)`);
    
    if (traderInitialized) {
      console.log("‚úÖ Au moins un trader initialis√© avec succ√®s");
      
      // V√©rifier la balance APR√àS l'initialisation des traders
      console.log("üí∞ V√©rification de la balance...");
      const balance = await checkBalance();
      console.log(`üí∞ Balance disponible: ${balance.available} USDC`);
      
      // Envoyer le message de d√©marrage avec la vraie balance
      await telegramService.sendBotReady(balance.available);
      
      // Initialiser l'orchestrateur de positions
      console.log("üéØ Initialisation de l'orchestrateur de positions...");
      positionOrchestrator = new PositionOrchestrator(
        hyperliquidTrader,
        binanceTrader,
        bybitTrader,
        telegramService,
        riskManager,
        performanceMonitor,
        retryManager
      );
      console.log("‚úÖ Orchestrateur de positions initialis√©");
      
      // Initialiser la file d'attente avec l'orchestrateur
      listingQueue = new ListingQueue(
        telegramService,
        hyperliquidTrader,
        riskManager,
        performanceMonitor
      );
      console.log("‚úÖ File d'attente initialis√©e");
      
    } else {
      console.log("‚ö†Ô∏è Aucun trader initialis√© - Mode surveillance uniquement");
      
      // Envoyer le message de d√©marrage avec balance 0
      await telegramService.sendBotReady(0);
    }



    // D√©marrer le health check
    console.log("üè• D√©marrage du health check...");
    startHealthCheck();
    console.log("‚úÖ Health check d√©marr√©");



    // Surveillance articles Bithumb d√©sactiv√©e (Cloudflare protection)
      console.log("üì∞ Surveillance articles Bithumb d√©sactiv√©e (Cloudflare protection)");

    // Gestionnaire des nouveaux listings avec monitoring et analyse globale
    async function handleNewListing(listing: KoreanListingEvent) {
      const detectionStart = Date.now();
      const symbol = listing.symbol;
      const metadata = {
        exchange: listing.exchange,
        source: listing.exchange === 'BITHUMB' ? 'websocket' : 'api',
        price: listing.price,
        volume: listing.volume,
        timestamp: listing.timestamp,
        fullSymbol: listing.fullSymbol
      };
      
      if (isRailway) {
        // Logs compacts pour Railway
        console.log(`üÜï NOUVEAU LISTING: ${symbol} | ${metadata.exchange || metadata.source || 'N/A'} | ${metadata.price || 'N/A'}`);
      } else {
        // Logs d√©taill√©s pour d√©veloppement
      console.log(`üÜï NOUVEAU LISTING D√âTECT√â !`);
        console.log(`üìä Symbole : ${symbol}`);
      if (metadata) {
          console.log(`üè¢ Exchange : ${metadata.exchange || metadata.source || 'N/A'}`);
          console.log(`üîó March√© complet : ${metadata.fullSymbol || symbol}`);
          console.log(`üí∞ Prix : ${metadata.price || 'N/A'}`);
          console.log(`üìà Volume : ${metadata.volume || 'N/A'}`);
          console.log(`‚è∞ Timestamp : ${new Date(metadata.timestamp || Date.now()).toLocaleString()}`);
        }
        console.log(`‚ö° Temps de d√©tection : ${Date.now() - detectionStart}ms`);
        console.log(`---`);
      }

      // Enregistrer la d√©tection
      if (performanceMonitor) {
        performanceMonitor.recordDetection(symbol, Date.now() - detectionStart);
      }

      // Notification Telegram s√©curis√©e
      const price = metadata?.price ? metadata.price.toString() : 'N/A';
      const exchange = metadata?.exchange || metadata.source || 'N/A';
      await telegramService?.sendNewListing(symbol, price, exchange);

      // ANALYSE GLOBALE - V√©rifier si le token est list√© globalement
      if (globalTokenManager) {
        if (!isRailway) {
          console.log(`üåç Analyse globale pour ${symbol}...`);
        }
        const analysis = await globalTokenManager.analyzeKoreanListing(symbol, metadata);
        
        // Log de l'analyse
        if (isRailway) {
          console.log(`üìä Analyse: ${symbol} | ${analysis.eventType} | ${analysis.priority}`);
        } else {
          console.log(`üìä R√©sultat analyse: ${analysis.eventType} - Priorit√©: ${analysis.priority}`);
        }
        
        // Si c'est un trigger bullish cor√©en avec perp disponible, action imm√©diate
        if (analysis.eventType === 'bullish_korean_trigger' && analysis.recommendedExchange) {
          console.log(`üî• TRIGGER BULLISH D√âTECT√â - Action imm√©diate recommand√©e sur ${analysis.recommendedExchange}`);
        }
      }

      // D√©terminer la source du listing
      let source: 'announcement' | 'websocket' | 'api' = 'api';
      if (metadata?.source?.includes('Article') || metadata?.source?.includes('announcement')) {
        source = 'announcement';
      } else if (metadata?.source?.includes('WebSocket')) {
        source = 'websocket';
      }

      // NOUVEAU SYST√àME - Utiliser l'orchestrateur de positions
      if (positionOrchestrator && traderInitialized) {
        const listingEvent: ListingEvent = {
          symbol,
          metadata,
          detectionTime: Date.now(),
          id: `${Date.now()}-${symbol}` // ID unique pour l'idempotency
        };

        console.log(`üéØ Tentative d'ouverture de position pour ${symbol}...`);
        
        try {
          const tradeResult = await positionOrchestrator.openPositionForNewListing(listingEvent);
          
          if (tradeResult.success) {
            console.log(`‚úÖ Position ouverte avec succ√®s: ${symbol} sur ${tradeResult.venue}`);
          } else {
            console.log(`‚ùå √âchec ouverture position: ${symbol} - ${tradeResult.error}`);
            
            // Fallback vers l'ancien syst√®me de file d'attente
            if (listingQueue) {
              console.log(`üìã Ajout de ${symbol} √† la file d'attente (fallback)`);
              listingQueue.addListing(symbol, metadata, source);
            }
          }
        } catch (error) {
          console.error(`‚ùå Erreur orchestrateur pour ${symbol}:`, error);
          
          // Fallback vers l'ancien syst√®me
          if (listingQueue) {
            console.log(`üìã Ajout de ${symbol} √† la file d'attente (erreur)`);
            listingQueue.addListing(symbol, metadata, source);
          }
        }
      } else {
        // Fallback vers l'ancien syst√®me si l'orchestrateur n'est pas disponible
        if (listingQueue && traderInitialized) {
          if (!isRailway) {
            console.log(`üìã Ajout de ${symbol} √† la file d'attente (source: ${source})`);
          }
          listingQueue.addListing(symbol, metadata, source);
          
          // V√©rification imm√©diate pour les WebSockets (d√©j√† list√©s)
          if (source === 'websocket') {
            if (!isRailway) {
              console.log(`üîç V√©rification imm√©diate WebSocket pour ${symbol}`);
            }
            // Note: processImmediate n'existe pas, on utilise addListing
          }
        }
      }
    }
  } catch (error) {
    console.error('‚ùå Erreur critique dans startBot:', error);
    
    // Notification d'erreur critique
    if (telegramService) {
      await telegramService.sendBotReady(0); // Fallback simple
    }
  }
}

// D√©marrer le bot
startBot().catch(error => {
  console.error('‚ùå Erreur fatale au d√©marrage du bot:', error);
  process.exit(1);
});