import { AlternativeListingSource } from "./alternativeListingSource";
import { executeTrade, initializeTrader, checkBalance } from "./trader";
import { TelegramService } from "./telegramService";
import { startHealthCheck } from './healthCheck';
import { HyperliquidWebSocket } from './hyperliquidWebSocket';
import { HyperliquidTrader } from './hyperliquidTrader';
import { validateHyperliquidConfig } from './hyperliquidConfig';
import { BithumbArticleScraper } from './bithumbArticleScraper';
import { TradeRetryManager } from './retryManager';
import { PerformanceMonitor } from './performanceMonitor';
import { RiskManager } from './riskManager';
import { StatusReporter } from './statusReporter';

console.log("üöÄ Frontrun Bot is running!");

// D√©marrer le health check pour Railway
console.log("üè• Starting health check server...");
try {
  startHealthCheck();
  console.log("‚úÖ Health check server started successfully");
} catch (error) {
  console.error("‚ùå Failed to start health check server:", error);
}

// Variables globales
let traderInitialized = false;
let listingSource: AlternativeListingSource | null = null;
let hyperliquidWebSocket: HyperliquidWebSocket | null = null;
let hyperliquidTrader: HyperliquidTrader | null = null;
let telegramService: TelegramService | null = null;
let articleScraper: BithumbArticleScraper | null = null;
let retryManager: TradeRetryManager | null = null;
let performanceMonitor: PerformanceMonitor | null = null;
let riskManager: RiskManager | null = null;

async function startBot() {
  try {
    console.log("ü§ñ Initialisation du bot...");
    
    // Initialiser le rapporteur de statut
    const statusReporter = new StatusReporter();
    statusReporter.startReporting();
    
    // Valider la configuration Hyperliquid
    validateHyperliquidConfig();
    
    // Initialiser le service Telegram
    telegramService = new TelegramService();
    await telegramService.sendBotStatus("D√©marrage", "Initialisation du bot...");

    // Initialiser les nouveaux modules
    console.log("üìä Initialisation des modules avanc√©s...");
    retryManager = new TradeRetryManager(telegramService);
    performanceMonitor = new PerformanceMonitor(telegramService);
    riskManager = new RiskManager(telegramService);
    articleScraper = new BithumbArticleScraper(telegramService);

    // Connecter le service Telegram au trader
    const { setTelegramService, setRiskManager } = await import('./trader');
    setTelegramService(telegramService);
    if (riskManager) {
      setRiskManager(riskManager);
    }

    // Initialiser le trader Hyperliquid avec retry
    console.log("üîß Initialisation du trader Hyperliquid...");
    hyperliquidTrader = new HyperliquidTrader();
    
    if (retryManager) {
      traderInitialized = await retryManager.executeWithRetry(
        () => hyperliquidTrader!.initialize(),
        "Initialisation Hyperliquid"
      );
    } else {
      traderInitialized = await hyperliquidTrader.initialize();
    }
    
    if (!traderInitialized) {
      console.warn("‚ö†Ô∏è Hyperliquid non initialis√© - Mode surveillance uniquement");
      await telegramService.sendBotStatus("Mode surveillance", "Hyperliquid non configur√© - Surveillance active uniquement");
      // Ne pas arr√™ter le bot, continuer en mode surveillance
    } else {
      await telegramService.sendBotStatus("Trader initialis√©", "Hyperliquid configur√© avec succ√®s");

      // V√©rifier la balance avec retry seulement si le trader est initialis√©
      try {
        let balance;
        if (retryManager) {
          balance = await retryManager.executeWithRetry(
            () => hyperliquidTrader!.checkBalance(),
            "V√©rification balance"
          );
        } else {
          balance = await hyperliquidTrader.checkBalance();
        }
        await telegramService.sendBalanceUpdate(balance);
      } catch (error) {
        console.warn("‚ö†Ô∏è Impossible de v√©rifier la balance, mais le bot continue...");
        await telegramService.sendBotStatus("Balance non disponible", "Mode d√©grad√© - trading d√©sactiv√©");
      }
    }

    // Initialiser la surveillance des listings
    listingSource = new AlternativeListingSource();
    await telegramService.sendBotStatus("Surveillance activ√©e", "D√©tection des nouveaux listings en cours...");

    // Initialiser le WebSocket Hyperliquid seulement si configur√©
    if (traderInitialized) {
      // Temporairement d√©sactiv√© - probl√®me de stabilit√© WebSocket
      console.log('‚ö†Ô∏è WebSocket Hyperliquid temporairement d√©sactiv√© (probl√®me de stabilit√©)');
      // hyperliquidWebSocket = new HyperliquidWebSocket();
      // await hyperliquidWebSocket.startListening(handleNewListing);
    }

    // D√©marrer la surveillance des articles Bithumb (d√©sactiv√© temporairement)
    if (articleScraper) {
      // await articleScraper.startMonitoring();
      console.log("üì∞ Surveillance articles Bithumb d√©sactiv√©e (Cloudflare protection)");
    }

    // Gestionnaire des nouveaux listings avec monitoring
    async function handleNewListing(symbol: string, metadata?: any) {
      const detectionStart = Date.now();
      
      console.log(`üÜï NOUVEAU LISTING D√âTECT√â !`);
      console.log(`Symbole : ${symbol}`);
      if (metadata) {
        console.log(`Exchange : ${metadata.exchange}`);
        console.log(`March√© complet : ${metadata.fullSymbol}`);
      }

      // Enregistrer la d√©tection
      if (performanceMonitor) {
        performanceMonitor.recordDetection(symbol, Date.now() - detectionStart);
      }

      // Notification Telegram
      await telegramService?.sendNewListing(symbol, metadata);

      // V√©rifier si le perp√©tuel existe sur Hyperliquid avec retry seulement si le trader est initialis√©
      if (traderInitialized && hyperliquidTrader) {
        let hasPerpHyperliquid = false;
        try {
          if (retryManager) {
            hasPerpHyperliquid = await retryManager.executeWithRetry(
              () => hyperliquidTrader!.hasPerp(symbol),
              `V√©rification perp ${symbol}`
            );
          } else {
            const result = await hyperliquidTrader?.hasPerp(symbol);
            hasPerpHyperliquid = result === true;
          }
        } catch (error) {
          console.error(`‚ùå Erreur v√©rification perp ${symbol}:`, error);
        }

        if (hasPerpHyperliquid) {
          console.log(`‚úÖ Perp d√©tect√© sur Hyperliquid ! V√©rification des risques...`);
          
          // V√©rification des risques avant le trade
          if (riskManager) {
            const riskCheck = await riskManager.canTrade(symbol, 400); // Montant par d√©faut
            
            if (!riskCheck.allowed) {
              console.log(`üõ°Ô∏è Trade bloqu√©: ${riskCheck.reason}`);
              await telegramService?.sendBotStatus("Trade bloqu√©", `${symbol}: ${riskCheck.reason}`);
              return; // Arr√™ter ici
            }
            
            console.log(`üõ°Ô∏è V√©rification risque: AUTORIS√â`);
          }
          
          await telegramService?.sendBotStatus("Trade Hyperliquid", `Ouverture position sur ${symbol}`);
          
          const tradeStart = Date.now();
          try {
            if (retryManager) {
              await retryManager.executeTradeWithRetry(
                () => executeTrade(symbol, 'Hyperliquid'),
                symbol,
                'Hyperliquid'
              );
            
              // Enregistrer le trade r√©ussi
              if (performanceMonitor) {
                performanceMonitor.recordTrade(
                  symbol,
                  'Hyperliquid',
                  Date.now() - detectionStart,
                  Date.now() - tradeStart,
                  true
                );
              }
              
              // Enregistrer dans le risk manager
              if (riskManager) {
                await riskManager.recordTrade(symbol, 400);
              }
            } else {
              await executeTrade(symbol, 'Hyperliquid');
            }
          } catch (error) {
            console.error(`‚ùå Erreur trade ${symbol}:`, error);
            
            // Enregistrer le trade √©chou√©
            if (performanceMonitor) {
              performanceMonitor.recordTrade(
                symbol,
                'Hyperliquid',
                Date.now() - detectionStart,
                Date.now() - tradeStart,
                false,
                undefined,
                error instanceof Error ? error.message : String(error)
              );
            }
          }
        } else {
          console.log(`‚ùå Perp non disponible sur Hyperliquid pour ${symbol}`);
          await telegramService?.sendBotStatus("Aucun perp trouv√©", `${symbol} non disponible sur Hyperliquid`);
        }
      } else {
        console.log(`üìä Listing d√©tect√©: ${symbol} (Mode surveillance uniquement - Hyperliquid non configur√©)`);
        await telegramService?.sendBotStatus("Listing d√©tect√©", `${symbol} - Mode surveillance uniquement`);
      }
    }

    // D√©marrer la surveillance
    listingSource.startListening(handleNewListing);

    // Notification de d√©marrage r√©ussi
    const statusMessage = traderInitialized 
      ? "Bot op√©rationnel - Surveillance active - pr√™t √† d√©tecter les nouveaux listings"
      : "Bot op√©rationnel - Mode surveillance uniquement (Hyperliquid non configur√©)";
    
    await telegramService.sendBotStatus("Bot op√©rationnel", statusMessage);
    
    // Envoyer rapport de risque initial
    if (riskManager) {
      await riskManager.sendDailyRiskReport();
    }

  } catch (error) {
    console.error('‚ùå Erreur lors du d√©marrage du bot:', error);
    await telegramService?.sendError('Erreur de d√©marrage', error instanceof Error ? error.message : 'Erreur inconnue');
    // Ne pas arr√™ter le processus, laisser le health check continuer
    console.log('üîÑ Red√©marrage automatique dans 30 secondes...');
    setTimeout(() => {
      startBot();
    }, 30000);
  }
}

// Gestion des signaux d'arr√™t
const gracefulShutdown = async (signal: string) => {
  console.log(`\nüõë Arr√™t du bot (${signal})...`);
  try {
    await telegramService?.sendBotStatus("Arr√™t", `Bot arr√™t√© (${signal})`);
    
    // Arr√™ter tous les modules
    if (listingSource) {
      listingSource.stopListening();
    }
    // Temporairement d√©sactiv√© - WebSocket Hyperliquid d√©sactiv√©
    // if (hyperliquidWebSocket && typeof hyperliquidWebSocket.stopListening === 'function') {
    //   hyperliquidWebSocket.stopListening();
    // }
    if (articleScraper) {
      await articleScraper.stopMonitoring();
    }
    
    // Envoyer rapport final
    if (performanceMonitor) {
      await performanceMonitor.sendDailyReport();
    }
    
    console.log('‚úÖ Arr√™t propre termin√©');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'arr√™t:', error);
    process.exit(1);
  }
};

process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

// Gestion des erreurs non captur√©es
process.on('uncaughtException', async (error) => {
  console.error('‚ùå Erreur non captur√©e:', error);
  await telegramService?.sendError('Erreur fatale', error.message);
  process.exit(1);
});

process.on('unhandledRejection', async (reason, promise) => {
  console.error('‚ùå Promesse rejet√©e non g√©r√©e:', reason);
  await telegramService?.sendError('Promesse rejet√©e', String(reason));
  process.exit(1);
});

// D√©marrer le bot avec un d√©lai pour laisser le health check se stabiliser
setTimeout(() => {
  startBot();
}, 2000);