import { checkBalance, setHyperliquidTrader, setBybitTrader } from "./trader";
import { TelegramService } from "./telegramService";
import { startHealthCheck } from './healthCheck';

import { HyperliquidTrader } from './hyperliquidTrader';
import { BinanceTrader } from './binanceTrader';
import { BybitTrader } from './bybitTrader';
import { validateHyperliquidConfig } from './hyperliquidConfig';
import { TradeRetryManager } from './retryManager';
import { PerformanceMonitor } from './performanceMonitor';
import { RiskManager } from './riskManager';
import { DiagnosticTool } from './diagnostic';
import { ListingQueue } from './listingQueue';
import { GlobalTokenManager } from './globalTokenManager';
import { PositionOrchestrator, ListingEvent } from './execution/positionOrchestrator';
import { ListingSurveillance, KoreanListingEvent } from './listingSurveillance';

console.log("üöÄ Frontrun Bot is running!");

// Mode Railway - r√©duire les logs pour √©viter les probl√®mes de performance
const isRailway = process.env.RAILWAY_ENVIRONMENT || process.env.NODE_ENV === 'production';
if (isRailway) {
  console.log("üöÇ Mode Railway d√©tect√© - Logs optimis√©s activ√©s");
}

// Variables globales
let traderInitialized = false;

let hyperliquidTrader: HyperliquidTrader | undefined = undefined;
let telegramService: TelegramService | null = null;
let retryManager: TradeRetryManager | null = null;
let performanceMonitor: PerformanceMonitor | null = null;
let riskManager: RiskManager | null = null;
let listingQueue: ListingQueue | null = null;
let globalTokenManager: GlobalTokenManager | null = null;
let positionOrchestrator: PositionOrchestrator | null = null;
let listingSurveillance: ListingSurveillance | null = null;



async function startBot() {
  try {
    console.log("ü§ñ Initialisation du bot...");
    
    // Diagnostic syst√®me au d√©marrage
    console.log("üîç Ex√©cution du diagnostic syst√®me...");
    const diagnosticTool = new DiagnosticTool();
    await diagnosticTool.runDiagnostic();
    
    // Initialiser le rapporteur de statut
    // const statusReporter = new StatusReporter();
    // statusReporter.startReporting();
    // D√âSACTIV√â - Rapport automatique toutes les 2h (source possible de spam)
    
    // Valider la configuration Hyperliquid
    validateHyperliquidConfig();
    
    // Initialiser le service Telegram s√©curis√©
    telegramService = new TelegramService();
    
    // V√©rifier la balance et envoyer le message de d√©marrage s√©curis√©
    const balance = await checkBalance();
    await telegramService.sendBotReady(balance.available);

    // Initialiser les nouveaux modules
    console.log("üìä Initialisation des modules avanc√©s...");
    retryManager = new TradeRetryManager(telegramService);
    performanceMonitor = new PerformanceMonitor(telegramService);
    riskManager = new RiskManager(telegramService);
    // Article scraper d√©sactiv√© (Cloudflare protection)

    // Initialiser le gestionnaire de tokens globaux
    console.log("üåç Initialisation du gestionnaire de tokens globaux...");
    globalTokenManager = new GlobalTokenManager(telegramService);
    
    // D√©sactiver la surveillance globale par d√©faut - Focus sur Cor√©e
    if (process.env.ENABLE_GLOBAL_MONITORING === 'true') {
      globalTokenManager.startGlobalMonitoring();
    } else {
      console.log("‚è∏Ô∏è Surveillance globale d√©sactiv√©e - Focus sur frontrunning cor√©en");
    }

    // Initialiser la surveillance des listings cor√©ens
    console.log("üá∞üá∑ Initialisation de la surveillance des listings cor√©ens...");
    listingSurveillance = new ListingSurveillance(handleNewListing);
    await listingSurveillance.start();



    // Initialiser les traders
    console.log("üí∞ Initialisation des traders...");
    
    // Initialiser Hyperliquid (priorit√©)
    if (process.env.HL_ENABLED === '1') {
    console.log("üîß Initialisation du trader Hyperliquid...");
    hyperliquidTrader = new HyperliquidTrader();
      const hlInitialized = await hyperliquidTrader.initialize();
      if (hlInitialized) {
        console.log("‚úÖ Trader Hyperliquid initialis√© avec succ√®s");
        traderInitialized = true;
        // Synchroniser avec trader.ts
        setHyperliquidTrader(hyperliquidTrader);
    } else {
        console.log("‚ö†Ô∏è √âchec initialisation Hyperliquid");
      }
    }

    // Initialiser Binance (si activ√©)
    let binanceTrader: BinanceTrader | undefined = undefined;
    if (process.env.BINANCE_ENABLED === '1') {
      console.log("üîß Initialisation du trader Binance...");
      binanceTrader = new BinanceTrader(telegramService);
      const binanceInitialized = await binanceTrader.initialize();
      if (binanceInitialized) {
        console.log("‚úÖ Trader Binance initialis√© avec succ√®s");
        if (!traderInitialized) traderInitialized = true;
    } else {
        console.log("‚ö†Ô∏è √âchec initialisation Binance");
      }
    }

    // Initialiser Bybit (si activ√©)
    let bybitTrader: BybitTrader | undefined = undefined;
    if (process.env.BYBIT_ENABLED === '1') {
      console.log("üîß Initialisation du trader Bybit...");
      bybitTrader = new BybitTrader();
      const bybitInitialized = await bybitTrader.initialize();
      if (bybitInitialized) {
        console.log("‚úÖ Trader Bybit initialis√© avec succ√®s");
        if (!traderInitialized) traderInitialized = true;
        } else {
        console.log("‚ö†Ô∏è √âchec initialisation Bybit");
      }
    }
    
    if (traderInitialized) {
      console.log("‚úÖ Au moins un trader initialis√© avec succ√®s");
      
      // Initialiser l'orchestrateur de positions
      console.log("üéØ Initialisation de l'orchestrateur de positions...");
      positionOrchestrator = new PositionOrchestrator(
        hyperliquidTrader,
        binanceTrader,
        bybitTrader,
        telegramService,
        riskManager,
        performanceMonitor,
        retryManager
      );
      console.log("‚úÖ Orchestrateur de positions initialis√©");
      
      // V√©rifier la balance
      const balance = await checkBalance();
      console.log(`üí∞ Balance disponible: ${balance.available} USDC`);
      
      // Initialiser la file d'attente avec l'orchestrateur
      listingQueue = new ListingQueue(
        telegramService,
        hyperliquidTrader,
        riskManager,
        performanceMonitor
      );
      console.log("‚úÖ File d'attente initialis√©e");
      
    } else {
      console.log("‚ö†Ô∏è Aucun trader initialis√© - Mode surveillance uniquement");
    }



    // D√©marrer le health check
    console.log("üè• D√©marrage du health check...");
    startHealthCheck();
    console.log("‚úÖ Health check d√©marr√©");



    // Surveillance articles Bithumb d√©sactiv√©e (Cloudflare protection)
      console.log("üì∞ Surveillance articles Bithumb d√©sactiv√©e (Cloudflare protection)");

    // Gestionnaire des nouveaux listings avec monitoring et analyse globale
    async function handleNewListing(listing: KoreanListingEvent) {
      const detectionStart = Date.now();
      const symbol = listing.symbol;
      const metadata = {
        exchange: listing.exchange,
        source: listing.exchange === 'BITHUMB' ? 'websocket' : 'api',
        price: listing.price,
        volume: listing.volume,
        timestamp: listing.timestamp,
        fullSymbol: listing.fullSymbol
      };
      
      if (isRailway) {
        // Logs compacts pour Railway
        console.log(`üÜï NOUVEAU LISTING: ${symbol} | ${metadata.exchange || metadata.source || 'N/A'} | ${metadata.price || 'N/A'}`);
      } else {
        // Logs d√©taill√©s pour d√©veloppement
      console.log(`üÜï NOUVEAU LISTING D√âTECT√â !`);
        console.log(`üìä Symbole : ${symbol}`);
      if (metadata) {
          console.log(`üè¢ Exchange : ${metadata.exchange || metadata.source || 'N/A'}`);
          console.log(`üîó March√© complet : ${metadata.fullSymbol || symbol}`);
          console.log(`üí∞ Prix : ${metadata.price || 'N/A'}`);
          console.log(`üìà Volume : ${metadata.volume || 'N/A'}`);
          console.log(`‚è∞ Timestamp : ${new Date(metadata.timestamp || Date.now()).toLocaleString()}`);
        }
        console.log(`‚ö° Temps de d√©tection : ${Date.now() - detectionStart}ms`);
        console.log(`---`);
      }

      // Enregistrer la d√©tection
      if (performanceMonitor) {
        performanceMonitor.recordDetection(symbol, Date.now() - detectionStart);
      }

      // Notification Telegram s√©curis√©e
      const price = metadata?.price ? metadata.price.toString() : 'N/A';
      const exchange = metadata?.exchange || metadata.source || 'N/A';
      await telegramService?.sendNewListing(symbol, price, exchange);

      // ANALYSE GLOBALE - V√©rifier si le token est list√© globalement
      if (globalTokenManager) {
        if (!isRailway) {
          console.log(`üåç Analyse globale pour ${symbol}...`);
        }
        const analysis = await globalTokenManager.analyzeKoreanListing(symbol, metadata);
        
        // Log de l'analyse
        if (isRailway) {
          console.log(`üìä Analyse: ${symbol} | ${analysis.eventType} | ${analysis.priority}`);
        } else {
          console.log(`üìä R√©sultat analyse: ${analysis.eventType} - Priorit√©: ${analysis.priority}`);
        }
        
        // Si c'est un trigger bullish cor√©en avec perp disponible, action imm√©diate
        if (analysis.eventType === 'bullish_korean_trigger' && analysis.recommendedExchange) {
          console.log(`üî• TRIGGER BULLISH D√âTECT√â - Action imm√©diate recommand√©e sur ${analysis.recommendedExchange}`);
        }
      }

      // D√©terminer la source du listing
      let source: 'announcement' | 'websocket' | 'api' = 'api';
      if (metadata?.source?.includes('Article') || metadata?.source?.includes('announcement')) {
        source = 'announcement';
      } else if (metadata?.source?.includes('WebSocket')) {
        source = 'websocket';
      }

      // NOUVEAU SYST√àME - Utiliser l'orchestrateur de positions
      if (positionOrchestrator && traderInitialized) {
        const listingEvent: ListingEvent = {
          symbol,
          metadata,
          detectionTime: Date.now(),
          id: `${Date.now()}-${symbol}` // ID unique pour l'idempotency
        };

        console.log(`üéØ Tentative d'ouverture de position pour ${symbol}...`);
        
        try {
          const tradeResult = await positionOrchestrator.openPositionForNewListing(listingEvent);
          
          if (tradeResult.success) {
            console.log(`‚úÖ Position ouverte avec succ√®s: ${symbol} sur ${tradeResult.venue}`);
          } else {
            console.log(`‚ùå √âchec ouverture position: ${symbol} - ${tradeResult.error}`);
            
            // Fallback vers l'ancien syst√®me de file d'attente
            if (listingQueue) {
              console.log(`üìã Ajout de ${symbol} √† la file d'attente (fallback)`);
              listingQueue.addListing(symbol, metadata, source);
            }
          }
        } catch (error) {
          console.error(`‚ùå Erreur orchestrateur pour ${symbol}:`, error);
          
          // Fallback vers l'ancien syst√®me
          if (listingQueue) {
            console.log(`üìã Ajout de ${symbol} √† la file d'attente (erreur)`);
            listingQueue.addListing(symbol, metadata, source);
          }
        }
      } else {
        // Fallback vers l'ancien syst√®me si l'orchestrateur n'est pas disponible
      if (listingQueue && traderInitialized) {
          if (!isRailway) {
        console.log(`üìã Ajout de ${symbol} √† la file d'attente (source: ${source})`);
          }
        listingQueue.addListing(symbol, metadata, source);
        
        // V√©rification imm√©diate pour les WebSockets (d√©j√† list√©s)
        if (source === 'websocket') {
            if (!isRailway) {
          console.log(`üîç V√©rification imm√©diate pour ${symbol} (WebSocket)`);
            }
          const hasPerp = await hyperliquidTrader?.hasPerp(symbol);
          if (hasPerp) {
            console.log(`‚úÖ ${symbol} imm√©diatement disponible sur Hyperliquid !`);
            // Le trade sera g√©r√© par la file d'attente
          } else {
              if (!isRailway) {
            console.log(`‚è≥ ${symbol} pas encore disponible, surveillance en cours...`);
              }
          }
        } else {
            if (!isRailway) {
          console.log(`‚è≥ ${symbol} ajout√© √† la file d'attente pour surveillance continue...`);
            }
        }
      } else {
          if (!isRailway) {
        console.log(`üìä Listing d√©tect√©: ${symbol} (Mode surveillance uniquement - Hyperliquid non configur√©)`);
      }
    }
      }
    }

    console.log("üéâ Bot initialis√© avec succ√®s !");
    console.log("üìä Mode:", process.env.DRY_RUN === '1' ? 'DRY RUN' : 'PRODUCTION');
    console.log("üí∞ Balance:", await checkBalance());
    console.log("üîç Surveillance active...");

  } catch (error) {
    console.error("‚ùå Erreur lors de l'initialisation du bot:", error);
    process.exit(1);
  }
}

// Gestion des signaux d'arr√™t
const gracefulShutdown = async (signal: string) => {
  console.log(`\nüõë Arr√™t du bot (${signal})...`);
  try {
    // Notification d'arr√™t
    console.log(`üõë Bot arr√™t√© par signal: ${signal}`);
    
    // Arr√™ter tous les modules
    // if (listingSource) {
    //   listingSource.stopListening();
    // }
    

    

    
    // Arr√™ter la surveillance des listings cor√©ens
    if (listingSurveillance) {
      listingSurveillance.stop();
      console.log('‚úÖ Surveillance des listings cor√©ens arr√™t√©e');
    }
    
    // Arr√™ter le monitoring global
    if (globalTokenManager) {
      globalTokenManager.stopGlobalMonitoring();
      console.log('‚úÖ Monitoring global arr√™t√©');
    }
    
    // Arr√™ter la file d'attente
    if (listingQueue) {
      listingQueue.stopMonitoring();
      console.log('‚úÖ File d\'attente arr√™t√©e');
    }
    
    // Envoyer rapport final
    if (performanceMonitor) {
      await performanceMonitor.sendDailyReport();
    }
    
    console.log('‚úÖ Arr√™t propre termin√©');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'arr√™t:', error);
    process.exit(1);
  }
};

process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

// Gestion des erreurs non captur√©es
process.on('uncaughtException', async (error) => {
  console.error('‚ùå Erreur non captur√©e:', error);
  console.error(`üö® ERREUR FATALE: Bot arr√™t√© par erreur: ${error.message}`);
  process.exit(1);
});

process.on('unhandledRejection', async (reason, promise) => {
  console.error('‚ùå Promesse rejet√©e non g√©r√©e:', reason);
  console.error(`üö® ERREUR PROMESSE: Bot arr√™t√© par promesse rejet√©e: ${String(reason)}`);
  process.exit(1);
});

// D√©marrer le bot avec un d√©lai pour laisser le health check se stabiliser
setTimeout(() => {
  startBot();
}, 2000);